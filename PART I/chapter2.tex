\chapter{Implémentation}
\section{Structures de données}
La stratégie de recherche avec graphe requiert une représentation des entrées du problème, des états construisant une solution potentielle à ce dernier ainsi que le développement de ces états.
\subsection{Représentation du problème SAT}
Une instance du problème SAT peut être considérée comme un ensemble de clauses, chacune de ces clauses est une disjonction de littéraux. Dans ce rapport Nous proposons deux structures différentes pour les représenter que nous comparerons par la suite.
\subsubsection{Représentation matricielle}
Une première représentation serait d‘associer à chaque clause de l’instance un tableau de taille égale au nombre de variables logiques utilisés dont la i\up{ième}  case aura la valeur 1 si la variable \textit{i} est présente dans la clause, -1 si sa négation est présente, 0 sinon. Ainsi en représentant toutes les clauses on obtient une matrice dont chaque ligne est associée à une clause.\\
L’exemple suivant montre une instance du problème SAT et sa représentation matricielle:
\begin{flalign*}
x_{1} \lor \neg x_{2} \lor x_{5} \\
\neg x_{2} \lor x_{4} \lor x_{5} \\
\neg x_{1} \lor x_{2} \lor \neg x_{3}
\end{flalign*}
Ces clauses vont être représentée comme suit:
\begin{center}
	\parbox{.2\textwidth}{
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			1&-1&0&0&1\\
			\hline
			0&-1&0&1&1\\
			\hline
			-1&1&1&0&0\\
			\hline
		\end{tabular}}
\end{center}
\newpage

\subsubsection{Représentation par \textit{Bitset}}
On pourrait aussi aborder la représentation du point de vu littéral, c’est à dire associer à chaque littéral les clauses dans lesquels il est présent. Pour cela un tableau de bits appelé \textit{Bitset} pourrait être utilisé où chaque bit \textit{i} aurait la valeur 1 si la i\up{ième} clause contient le littéral, la valeur 0 sinon. On obtient donc un tableau de taille 2 fois le nombre de variables utilisés dont les entrés représentent les \textit{Bitsets} des littéraux.\\
Pour le même exemple vu précédemment on obtient les \textit{Bitsets} suivants:\\\\
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{tabular}{|c | c| c| c|}
			\hline
			$x_{1}$& 1 & 0 & 0 \\\hline
			$x_{2}$& 0 & 0 & 0 \\\hline
			$x_{3}$& 0 & 0 & 0 \\\hline
			$x_{4}$& 0 & 1 & 0 \\\hline
			$x_{5}$& 1 & 1 & 0 \\\hline
		\end{tabular}
	\end{minipage}
	\hfillx
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{tabular}{|c | c| c| c|}
			\hline
			$\neg x_{1}$& 0 & 0 & 1 \\\hline
			$\neg x_{2}$& 1 & 1 & 0 \\\hline
			$\neg x_{3}$& 0 & 0 & 1 \\\hline
			$\neg x_{4}$& 0 & 0 & 0 \\\hline
			$\neg x_{5}$& 0 & 0 & 0 \\\hline
		\end{tabular}
	\end{minipage}

\subsection{Représentation des états}
Une solution à une instance du problème SAT se réduit à l’assignation des valeurs de vérités aux variables logiques de cette instance. On peut considérer un état dans l’espace de recherche comme étant le choix de la valeur de vérité d’une des variables logiques, on obtient après une succession de choix une solution au problème qui peut être positive si les valeurs assignés sont consistante avec les clauses de l’instance, négative sinon. Nous allons représenter un état avec un noeud qui contient le numéro de la variable choisie, multiplié par -1 pour désigner l’assignation de la valeur $faux$ à la variable, il reste inchangé sinon.\\
\begin{center}
	\begin{forest} [
		[5[$x_{5} \leftarrow vrai$]]
		[-5[$x_{5} \leftarrow faux$]]
		]
	\end{forest}
\end{center}
\newpage
\subsection{Développement des états}
A partir de chaque état on peut faire le choix de la valeur de vérité d’une variable logique choisie aléatoirement. Le développement d’un noeud donne deux successeurs, un pour chaque valeur de vérité assignée à la prochaine variable. On obtient après l’exploration de l’espace de recherche un arbre d’états, l’exemple suivant est un arbre associé à une instance SAT contenant trois variables.\\
\begin{center}
	\begin{forest} [
		[2
			[1
				[3]
				[-3]
			]
			[-1
				[3]
				[-3]
			]
		]
		[-2
			[1
				[3]
				[-3]
			]
			[-1
				[3]
				[-3]
			]
		]
		]
	\end{forest}
\end{center}
Une solution est représentée par une branche de l’arbre, par exemple la solution : $x_{1} = vrai$, $x_{2} = faux$, $x_{3} = faux$ est représentée dans l’arbre précédent comme suit:
\begin{center}
	\begin{forest} [
		[2
		[1
		[3]
		[-3]
		]
		[-1
		[3]
		[-3]
		]
		]
		[-2, text=red
		[1, text=red
		[3]
		[-3, text=red]
		]
		[-1
		[3]
		[-3]
		]
		]
		]
	\end{forest}
\end{center}
Pour pouvoir construire une solution à partir de n’importe quel noeud, on doit y sauvegarder l’adresse de son parent, ainsi on peut récupérer les valeurs assignées aux noeuds précédents jusqu’à la racine. L’enregistrement suivant représente un noeud de l’arbre:

\begin{lstlisting}
struct {
int valeur; 
struct noeud* parent;
} noeud;
\end{lstlisting}

\textbf{Remarque1:} Un inconvénient que nous avons déjà cité de la recherche en largeur d’abord était la saturation rapide de la mémoire, cela est dû au fait de garder tous les noeuds dans la mémoire. Ce problème est évité dans la recherche en profondeur d’abord car dès l’évaluation d’un noeud se trouvant dans la profondeur maximale, ce dernier est supprimé de la mémoire. notons que la structure du noeud déjà présenté ne contient pas les adresses de ses successeurs, ceci nous permet d’éviter de garder tous l’arbre d’états dans la mémoire mais juste les branche susceptible d’être évaluée par la suite.\\~\\
\textbf{Remarque2:} Dans la deuxième représentation du problème SAT, une optimisation serait d’ajouter un $Bitset$ dans la structure du noeud et y garder les clauses qu’il satisfait ainsi que celles de ses parents, celui là peut être obtenu en appliquant l’opération OU logique sur le $Bitset$ du noeud parent et celui du littéral choisi.\\
\begin{center}
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{tabular}{|c | c| c| c|c|}
			\hline
			$Bitset$ du parent& 1 & 0 & 1 & 1 \\\hline
		\end{tabular}
	\end{minipage}
	\\~\\
	OR
	\\~\\
	\begin{minipage}{0.5\textwidth}
		\centering
		\begin{tabular}{|c | c| c| c|c|}
			\hline
			$Bitset$ du littéral& 1 & 0 & 0 & 1\\\hline
		\end{tabular}
	\end{minipage}
	\begin{center}

		$\downarrow$
		\\~\\
		\begin{tabular}{|c | c| c| c|c|}
			\hline
			$Bitset$ du noeud& 1 & 0 & 1 & 1\\\hline
		\end{tabular}
	\end{center}
\end{center}

\section{Conception et pseudo-code}
Dans cette partie nous allons présenter l’implémentation des algorithmes de recherche avec graphe, un algorithme générique qui englobe les différente méthodes est présenté si dessous:

\begin{algorithm}
	\SetAlgoLined
	\KwResult{retourne la solution ou échec}
	$open \gets \textbf{état initial}$\;
	initialiser l'ensemble $closed$ à \textbf{vide}\;
	\While{$\neg$\textbf{vide} $open$}{
		$noeud \gets$ \textbf{choisir\_noeud($open$)}\;
		\If{\textbf{noeud\_but}($noeud$)}{
			\Return \textbf{solution}($noeud$)\;
		}
		\textbf{ajouter}($noeud$,$closed$)\;
		$successeurs \gets$ \textbf{developper}($noeud$) \;
		inserer les $sueccesseurs$ qui n'appartiennent pas à $closed$ dans $open$ 
	}
	\Return echec\;
\caption{Algorithme de recherche avec graphe}
\end{algorithm}
La différence entre les algorithmes de recherche réside dans la manière dont on sélectionne le noeud à évaluer, ligne 4 dans l’algorithme si dessus, ainsi que l’estimation du coût et de l’heuristique, s’ils existent, avant l’insertion, ligne 10.\\
En se basant sur cette algorithme nous avons implémenter une procédure de recherche générique prenant en paramètre un type de gestion de liste, un estimateur de coût et d’heuristique et les entrés de l’instance SAT afin d’évaluer les noeuds.
\subsection{Gestion de la liste open}

\subsubsection{Profondeur d'abord}
La recherche en profondeur d’abord consiste à choisir le noeud avec la profondeur la plus élevé de l’arbre, ceci reviens à sélectionner l’élément le plus récemment inséré dans la liste open, c’est à dire, la gérer avec une politique LIFO.\\
Insertion d'un noeud:\\
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{|c |}
		\hline
		 3 \\
		\hline
	\end{tabular}
\end{minipage}
\hfillx
$\rightarrow$
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{|c | c| c| c|}
		\hline
		{\color{red}3} & -3 & -2 & -1 \\\hline
	\end{tabular}
\end{minipage}

Sélection d'un noeud:\\
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{|c |}
		\hline
		{\color{red}3} \\
		\hline
	\end{tabular}
\end{minipage}
\hfillx
$\leftarrow$
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{| c| c| c|}
		\hline
		-3 & -2 & -1 \\\hline
	\end{tabular}
\end{minipage}


\subsubsection{Largeur d'abord}
Contrairement à la recherche en profondeur d’abord, les noeuds sont visités de tel sorte à parcourir l’arbre niveau par niveau, cela peut être réalisé par la sélection du noeud le moins récemment insérer dans open, d’où une gestion LIFO de la liste.\\
Insertion d'un noeud:\\
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{|c |}
		\hline
		3 \\
		\hline
	\end{tabular}
\end{minipage}
\hfillx
$\rightarrow$
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{|c | c| c| c|}
		\hline
		{\color{red}3} & -3 & -2 & -1 \\\hline
	\end{tabular}
\end{minipage}

Sélection d'un noeud:\\
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{|c |}
		\hline
		{\color{red}-1} \\
		\hline
	\end{tabular}
\end{minipage}
\hfillx
$\leftarrow$
\begin{minipage}{0.5\textwidth}
	\centering
	\begin{tabular}{| c| c| c|}
		\hline
		3 & -3 & -2  \\\hline
	\end{tabular}
\end{minipage}

\subsubsection{Recherche En se basant sur une fonction d'évaluation}



